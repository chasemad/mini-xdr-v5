"""
Vulnerability Mapping Module

Maps discovered assets to known vulnerabilities and security weaknesses.
"""

import logging
from typing import Dict, List, Optional
from datetime import datetime

logger = logging.getLogger(__name__)


class VulnerabilityMapper:
    """
    Maps discovered assets to potential vulnerabilities.
    
    Uses port signatures, service versions, and OS types to identify
    potential security risks and prioritize remediation.
    """
    
    def __init__(self):
        # Common vulnerability patterns
        self.vulnerability_rules = {
            "SMB v1": {
                "description": "SMBv1 protocol enabled (EternalBlue vulnerability)",
                "severity": "critical",
                "cve": ["CVE-2017-0144"],
                "indicators": {"ports": [445], "services": ["SMB"]},
                "remediation": "Disable SMBv1, enable SMBv2/v3 only"
            },
            "RDP Exposed": {
                "description": "RDP service accessible",
                "severity": "high",
                "cve": ["CVE-2019-0708"],  # BlueKeep
                "indicators": {"ports": [3389]},
                "remediation": "Use VPN/Bastion for RDP access, enable NLA"
            },
            "Telnet Enabled": {
                "description": "Unencrypted Telnet service running",
                "severity": "high",
                "cve": [],
                "indicators": {"ports": [23]},
                "remediation": "Disable Telnet, use SSH instead"
            },
            "Default SNMP Community": {
                "description": "SNMP service with potential default community strings",
                "severity": "medium",
                "cve": [],
                "indicators": {"ports": [161, 162]},
                "remediation": "Change default SNMP community strings, use SNMPv3"
            },
            "Weak SSL/TLS": {
                "description": "Potentially weak SSL/TLS configuration",
                "severity": "medium",
                "cve": ["CVE-2014-3566"],  # POODLE
                "indicators": {"ports": [443]},
                "remediation": "Enforce TLS 1.2+, disable SSLv3 and TLS 1.0/1.1"
            },
            "Database Exposed": {
                "description": "Database service directly accessible",
                "severity": "high",
                "cve": [],
                "indicators": {"ports": [1433, 3306, 5432, 1521, 27017]},
                "remediation": "Restrict database access to application servers only"
            },
            "Unpatched Windows": {
                "description": "Windows system potentially unpatched",
                "severity": "high",
                "cve": [],
                "indicators": {"os_type": "Windows"},
                "remediation": "Enable automatic updates, apply latest patches"
            }
        }
    
    def scan_vulnerabilities(self, host: Dict) -> List[Dict]:
        """
        Scan a host for potential vulnerabilities.
        
        Args:
            host: Host details from scanner
            
        Returns:
            List of potential vulnerabilities
        """
        vulnerabilities = []
        open_ports = set(host.get("ports", []))
        os_type = host.get("os_type", "unknown")
        services = host.get("services", {})
        
        for vuln_name, vuln_rule in self.vulnerability_rules.items():
            is_vulnerable = False
            
            # Check port-based indicators
            required_ports = set(vuln_rule.get("indicators", {}).get("ports", []))
            if required_ports and required_ports.issubset(open_ports):
                is_vulnerable = True
            
            # Check any port indicators
            any_ports = set(vuln_rule.get("indicators", {}).get("ports", []))
            if any_ports and any_ports & open_ports:
                is_vulnerable = True
            
            # Check OS type
            required_os = vuln_rule.get("indicators", {}).get("os_type")
            if required_os and required_os == os_type:
                is_vulnerable = True
            
            if is_vulnerable:
                vulnerabilities.append({
                    "name": vuln_name,
                    "description": vuln_rule["description"],
                    "severity": vuln_rule["severity"],
                    "cve": vuln_rule["cve"],
                    "remediation": vuln_rule["remediation"],
                    "detected_at": datetime.utcnow().isoformat()
                })
        
        return vulnerabilities
    
    def assess_risk(self, host: Dict, vulnerabilities: List[Dict]) -> Dict:
        """
        Assess overall risk for a host.
        
        Args:
            host: Host details
            vulnerabilities: List of vulnerabilities
            
        Returns:
            Risk assessment
        """
        # Calculate risk score
        severity_scores = {
            "critical": 10,
            "high": 7,
            "medium": 4,
            "low": 1
        }
        
        total_score = sum(
            severity_scores.get(v["severity"], 0)
            for v in vulnerabilities
        )
        
        # Determine risk level
        if total_score >= 20:
            risk_level = "critical"
        elif total_score >= 10:
            risk_level = "high"
        elif total_score >= 5:
            risk_level = "medium"
        else:
            risk_level = "low"
        
        return {
            "host": host["ip"],
            "hostname": host.get("hostname"),
            "risk_level": risk_level,
            "risk_score": total_score,
            "vulnerability_count": len(vulnerabilities),
            "critical_vulnerabilities": sum(
                1 for v in vulnerabilities if v["severity"] == "critical"
            ),
            "high_vulnerabilities": sum(
                1 for v in vulnerabilities if v["severity"] == "high"
            ),
            "medium_vulnerabilities": sum(
                1 for v in vulnerabilities if v["severity"] == "medium"
            ),
            "low_vulnerabilities": sum(
                1 for v in vulnerabilities if v["severity"] == "low"
            ),
            "assessed_at": datetime.utcnow().isoformat()
        }
    
    def generate_remediation_plan(
        self,
        assessed_hosts: List[Dict]
    ) -> List[Dict]:
        """
        Generate prioritized remediation plan.
        
        Args:
            assessed_hosts: List of hosts with risk assessments
            
        Returns:
            Prioritized list of remediation actions
        """
        remediation_actions = []
        
        # Sort by risk score (highest first)
        sorted_hosts = sorted(
            assessed_hosts,
            key=lambda h: h.get("risk_assessment", {}).get("risk_score", 0),
            reverse=True
        )
        
        for host in sorted_hosts:
            for vuln in host.get("vulnerabilities", []):
                remediation_actions.append({
                    "host": host["ip"],
                    "hostname": host.get("hostname"),
                    "vulnerability": vuln["name"],
                    "severity": vuln["severity"],
                    "remediation": vuln["remediation"],
                    "cve": vuln["cve"]
                })
        
        return remediation_actions
    
    def map_vulnerabilities(self, classified_hosts: List[Dict]) -> List[Dict]:
        """
        Complete vulnerability mapping for all hosts.
        
        Args:
            classified_hosts: Classified hosts from AssetClassifier
            
        Returns:
            Hosts with vulnerability information
        """
        mapped_hosts = []
        
        for host in classified_hosts:
            # Scan for vulnerabilities
            vulnerabilities = self.scan_vulnerabilities(host)
            host["vulnerabilities"] = vulnerabilities
            
            # Assess risk
            risk_assessment = self.assess_risk(host, vulnerabilities)
            host["risk_assessment"] = risk_assessment
            
            mapped_hosts.append(host)
        
        logger.info(
            f"Vulnerability mapping complete: {len(mapped_hosts)} hosts assessed"
        )
        
        return mapped_hosts


if __name__ == "__main__":
    # Test vulnerability mapping
    test_hosts = [
        {
            "ip": "10.0.10.10",
            "hostname": "dc01.minicorp.local",
            "ports": [53, 88, 135, 139, 389, 445, 636, 3389],
            "os_type": "Windows",
            "classification": "Domain Controller"
        },
        {
            "ip": "10.0.10.30",
            "hostname": "fileserver01",
            "ports": [22, 23, 139, 445],  # Telnet is risky!
            "os_type": "Linux/Unix",
            "classification": "Linux Server"
        }
    ]
    
    mapper = VulnerabilityMapper()
    
    print("Testing Vulnerability Mapper")
    print("=" * 70)
    print()
    
    mapped = mapper.map_vulnerabilities(test_hosts)
    
    for host in mapped:
        print(f"Host: {host['ip']} ({host.get('hostname', 'unknown')})")
        print(f"  Classification: {host.get('classification')}")
        print(f"  Risk Level: {host['risk_assessment']['risk_level'].upper()}")
        print(f"  Risk Score: {host['risk_assessment']['risk_score']}")
        print(f"  Vulnerabilities: {len(host['vulnerabilities'])}")
        
        if host['vulnerabilities']:
            print("  Details:")
            for vuln in host['vulnerabilities']:
                print(f"    • [{vuln['severity'].upper()}] {vuln['name']}")
                print(f"      → {vuln['description']}")
                print(f"      → Fix: {vuln['remediation']}")
        print()
    
    print("Remediation Plan:")
    remediation = mapper.generate_remediation_plan(mapped)
    for i, action in enumerate(remediation, 1):
        print(f"  {i}. [{action['severity'].upper()}] {action['host']} - {action['vulnerability']}")
        print(f"     → {action['remediation']}")

